= Datenbankversionierung
:author: David Lehner
:hide-uri-scheme:
:revnumber: 1.0
:revdate: {docdate}
:revremark: SLIDEDEMO @ HTL Leonding
:encoding: utf-8
:lang: de
:doctype: article
//:icons: font
:customcss: css/presentation.css
//:revealjs_customtheme: css/sky.css
//:revealjs_customtheme: css/black.css
:revealjs_width: 1408
:revealjs_height: 792
:source-highlighter: highlightjs
//:revealjs_parallaxBackgroundImage: images/background-landscape-light-orange.jpg
//:revealjs_parallaxBackgroundSize: 4936px 2092px
//:highlightjs-theme: css/atom-one-light.css
// we want local served font-awesome fonts
:iconfont-remote!:
:iconfont-name: fonts/fontawesome/css/all
//:revealjs_parallaxBackgroundImage: background-landscape-light-orange.jpg
//:revealjs_parallaxBackgroundSize: 4936px 2092px
ifdef::env-ide[]
:imagesdir: ../images
endif::[]
ifndef::env-ide[]
:imagesdir: images
endif::[]
//:revealjs_theme: sky
//:title-slide-background-image: Developer-Workflow.png
:title-slide-transition: zoom
:title-slide-transition-speed: fast

Konzept, Technologien, Liquibase

== Einführung
* Verwaltung und Nachverfolgung von Änderungen
* Migrationen (automatische Anwendung auf verschiedenen Systemen)


[.notes]
****
* Bei der Datenbankversionierung geht es darum, Informationen über ältere Stände während der Entwicklung zu speichern.
* Die Verwaltung und Nachverfolgung von Änderungen ist wichtig.
* Verschiedene Konfigurationen für Verschiedene Umgebungen (Entwicklung, Production...)
* Mittels Profiles in Quarkus
* Dies wird erledigt mittels Migrationsskripte
****

== Was ist das Problem?
* Verlorene Informationen in der Entwicklung
* Schwierige Rückverfolgbarkeit und Wiederherstellung von früheren Ständen.
* Inkonsistenz zwischen verschiedenen Umgebungen (fehlerhafte Tabellen)
* Rollback Probleme

[.notes]
****
* Hauptsächliches Problem liegt in der Entwicklung
* Wird keine Datenbankversionierung verwendet, gehen Informationen über alte Stände verloren.
* Wird nun an einer neuen Funktionalität gearbeitet, wodurch die Datenbank verändert werden muss, kann es bei Problemen schwierig werden den Fehler zu finden bzw zu rekonstruieren.
* Man is sich schließlich nicht ganz sicher woher der Fehler kommt
* Die Entwickler können zudem auf ihren lokalen Maschinen andere Stände der Datenbank haben, wie auf Testumgebungen / Production Umgebungen.
* Mit einem Migrationsskript würde das überall gleich aussehen, bzw übernommen werden können.
* Falls ein Release in der Produktionsumgebung schiefgeht, gibt es keine einfache Möglichkeit, die Datenbank auf einen funktionierenden Zustand zurückzusetzen, ohne aufwändige manuelle Eingriffe vorzunehmen.
****

=== Beispiel (Ausgangssituation):
* Gemeinsame Datenbank
* CI-Tool in Verwendung
* Neue Funktionalität fordert Datenbankänderung

=== Beispiel (Problem):
* Beeinflusst Tests auf anderen Branches
* Änderungen müssen zurückgesetzt werden
* Wiederholung

=== Beispiel (Warum?):
* Hoher Aufwand
* Fehleranfälligkeit
* Blockieren anderer Teams, während Datenbankänderungen aktiv sind.

== Wie wird das Problem gelöst?
* Einsatz von Tools zur Datenbankversionierung wie Liquibase.
* Zentralisierte Verwaltung von Datenbankänderungen (Versionierung)
* Automatische Synchronisierung der Datenbank
** https://docs.liquibase.com/commands/inspection/diff.html[Unterschiede Herausfinden]
* Rollback-Mechanismus
* Konsistenz

[.notes]
****
* Zentralisierte...
** Alle Änderungen in einem ChangeLog
** Jedes Mitglied verfasst seine Änderungen in dieser Datei, bevor es auf der Datenbank angewendet wird
* Automatische Synchro
** Es kann automatisch überprüft werden welche Änderungen noch nicht in der Datenbank übernommen wurden
** Änderungen werden entsprechend ausgerollt "Liquibase update"
* Rollback - Mechanismus
** Verursacht Feature oder Release Probleme, können diese einfach mittels Migrationsskripten zurückverfolgt und gerollbacked werden
* Konsistenz
** Durch die Automatisierung der Datenbankänderungen können Entwickler problemlos in einer konsistenten Testumgebung arbeiten.
** Wenn ein Entwickler eine neue Umgebung einrichtet oder an einem Feature arbeitet, kann er die Datenbankversionierung verwenden, um sicherzustellen, dass alle notwendigen Änderungen konsistent angewendet werden.
** Neues ChangeLog erstellen, liquibase:update verwenden, fertig
****

== Liquibase
https://medium.com/@tgt1022/how-to-execute-database-migrations-with-liquibase-9318b8e5da19
https://appmaster.io/de/glossary/versionierung
https://www.informatik.hu-berlin.de/de/forschung/gebiete/wbi/teaching/studienDiplomArbeiten/finished/2004/rieche_expose_040520.pdf

* Open-Source-Lösung für Datenbankversionierung und -migration.
* Unterstützt diverse Datenbanken (auch NoSQL)

== https://www.baeldung.com/liquibase-vs-flyway[Alternativen]
* Flyway

=== https://www.baeldung.com/liquibase-vs-flyway[Gleichheiten]
* Open-Source
* Grundprinzip gleich
* Basierend auf Java
* CLIs vorhanden
* Hohe Unterstützung verschiedener Datenbanken

=== https://www.baeldung.com/liquibase-vs-flyway[Warum Liquibase?]
* Einfachere Darstellung von Veränderungen (SQL vs. SQL, XML, YAML, JSON)
* Striktere Namensgebung bei Flyway
** V = Versionised
** U = Undo
** R = Repeatable
** BSP: V01__Add_New_Column.sql

=== https://www.baeldung.com/liquibase-vs-flyway[Warum Liquibase?]
* Keine Filename Conventions bei Liquibase
* Ein "Haupt-file" beinhaltet alle veränderungen und Referenzen auf andere Files
* Reihung klarer bei Liquibase
** Nach definition in Root-File
** Flyway: In Filename angeben

=== https://www.baeldung.com/liquibase-vs-flyway[Warum Liquibase?]
* Rollback
** Liquibase: Via CLI: liquibase rollback ...
** Flyway: Nach Filenames (U = Undo)
* Kein Snapshot feature bei Flyway (aktueller Stand der DB)

== Workflow mit Grafik
image::Developer-Workflow.png[Developer Workflow]
1. ChangeSet erstellen, welches die Änderungen beinhaltet
2. liquibase update - Datenbank ändern
3. Änderungen am Code vornehmen, falls nötig
4. Applikation mit Datenbank testen
5. Commit von Applikation und Changeset

[.notes]
****
* Wenn Änderungen an der Datenbank durchgeführt werden müssen, muss lokal ein ChangeSet erstellt werden
* Liquibase update durchführen, um die Änderungen auf die Datenbank zu bringen
* Sind Änderungen in der Applikation nötig, sollten dies nun durchgeführt werden
* Test der Applikation mit Datenbankveränderungen
* Commit von ChangeSet und Applikation
****

== Live DEMO

== Aufsetzen
https://quarkus.io/guides/liquibase

== Verwendung

=== Create, Delete, Update
* Änderungen immer in ChangeLogs

=== Rollback
* liquibase rollback-count --count=2
* -''- rollback --tag=test
* auch programmatisch möglich
.
.
.

=== ORM-Mapper
image::ORM.png[]

== https://docs.liquibase.com/concepts/bestpractices.html[Best-Practices]
* Changelog Struktur
** Root-ChangeLog
** Files nach Versionen, oder Tabellen
* Maximal eine Änderung pro ChangeSet

== Vorteile
* Änderungen gespeichert
* Rollback feature, bei Fehlern oder arbeiten auf gemeinsamer DB
* Fehleranfälligkeit vermindert

== Nachteile
* Höherer Aufwand bei Erstellung des Projekts
* Funktionalität mit ORM-Mapper etwas umständlich


[.stretch]
image::img.png[]

[.lightbg,background-opacity="0.7"]
== Slide w/ text and background image

image::img.png[background, size="contain"]


* Topic 1
* Topic 2
* Topic 3

[%auto-animate]
== !

Matched element will be animated automatically!

[%auto-animate]
== !

[.highlight]
Matched element will be animated automatically!

And move to the right position!

[%hardbreaks]
⬆️
⬆️
⬆️


[%auto-animate]
== !

[source%linenums,js,data-id=planets]
----
let planets = [
  { name: 'mars', diameter: 6779 },
]
----

[%auto-animate]
== !

[source%linenums,js,data-id=planets]
----
let planets = [
  { name: 'mars', diameter: 6779 },
  { name: 'earth', diameter: 12742 },
  { name: 'jupiter', diameter: 139820 }
]
----

[%auto-animate]
== !

[source%linenums,js,data-id=planets]
----
let circumferenceReducer = ( c, planet ) => {
  return c + planet.diameter * Math.PI;
}

let planets = [
  { name: 'mars', diameter: 6779 },
  { name: 'earth', diameter: 12742 },
  { name: 'jupiter', diameter: 139820 }
]

let c = planets.reduce( circumferenceReducer, 0 )
----


[%auto-animate,auto-animate-unmatched=false]
== Unmatched

Introduction. (matched)

[%auto-animate,auto-animate-unmatched=false]
== Unmatched

Introduction. (matched)

This will be shown instantly ⚡ (unmatched)


[%auto-animate,auto-animate-duration=5]
== Duration

This animation...

[%auto-animate,auto-animate-duration=5]
== Duration

This animation...

...will take 5 seconds! ⌚


